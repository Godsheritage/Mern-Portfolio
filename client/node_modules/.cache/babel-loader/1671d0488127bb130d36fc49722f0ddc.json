{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nexport { AsyncAction };","map":{"version":3,"mappings":"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","names":["tslib_1","AsyncAction","_super","scheduler","work","_this","state","delay","closed","id","recycleAsyncId","requestAsyncId","setInterval","clearInterval","undefined","execute","Error","pending","error","_execute","errored","errorValue","e","_unsubscribe","actions","index"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/scheduler/AsyncAction.ts"],"sourcesContent":["import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}