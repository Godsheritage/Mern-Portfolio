{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nvar FilterOperator = /*@__PURE__*/function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n\nvar FilterSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.count = 0;\n    return _this;\n  }\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":"AAAA;AACA,OAAO,KAAKA,OAAZ,MAAyB,OAAzB;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,OAAO,SAASC,MAAT,CAAgBC,SAAhB,EAA2BC,OAA3B,EAAoC;EACvC,OAAO,SAASC,sBAAT,CAAgCC,MAAhC,EAAwC;IAC3C,OAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,cAAJ,CAAmBL,SAAnB,EAA8BC,OAA9B,CAAZ,CAAP;EACH,CAFD;AAGH;;AACD,IAAII,cAAc,GAAG,aAAe,YAAY;EAC5C,SAASA,cAAT,CAAwBL,SAAxB,EAAmCC,OAAnC,EAA4C;IACxC,KAAKD,SAAL,GAAiBA,SAAjB;IACA,KAAKC,OAAL,GAAeA,OAAf;EACH;;EACDI,cAAc,CAACC,SAAf,CAAyBC,IAAzB,GAAgC,UAAUC,UAAV,EAAsBL,MAAtB,EAA8B;IAC1D,OAAOA,MAAM,CAACM,SAAP,CAAiB,IAAIC,gBAAJ,CAAqBF,UAArB,EAAiC,KAAKR,SAAtC,EAAiD,KAAKC,OAAtD,CAAjB,CAAP;EACH,CAFD;;EAGA,OAAOI,cAAP;AACH,CATmC,EAApC;;AAUA,IAAIK,gBAAgB,GAAG,aAAe,UAAUC,MAAV,EAAkB;EACpDd,OAAO,CAACe,SAAR,CAAkBF,gBAAlB,EAAoCC,MAApC;;EACA,SAASD,gBAAT,CAA0BG,WAA1B,EAAuCb,SAAvC,EAAkDC,OAAlD,EAA2D;IACvD,IAAIa,KAAK,GAAGH,MAAM,CAACJ,IAAP,CAAY,IAAZ,EAAkBM,WAAlB,KAAkC,IAA9C;;IACAC,KAAK,CAACd,SAAN,GAAkBA,SAAlB;IACAc,KAAK,CAACb,OAAN,GAAgBA,OAAhB;IACAa,KAAK,CAACC,KAAN,GAAc,CAAd;IACA,OAAOD,KAAP;EACH;;EACDJ,gBAAgB,CAACJ,SAAjB,CAA2BU,KAA3B,GAAmC,UAAUC,KAAV,EAAiB;IAChD,IAAIC,MAAJ;;IACA,IAAI;MACAA,MAAM,GAAG,KAAKlB,SAAL,CAAeO,IAAf,CAAoB,KAAKN,OAAzB,EAAkCgB,KAAlC,EAAyC,KAAKF,KAAL,EAAzC,CAAT;IACH,CAFD,CAGA,OAAOI,GAAP,EAAY;MACR,KAAKN,WAAL,CAAiBO,KAAjB,CAAuBD,GAAvB;MACA;IACH;;IACD,IAAID,MAAJ,EAAY;MACR,KAAKL,WAAL,CAAiBQ,IAAjB,CAAsBJ,KAAtB;IACH;EACJ,CAZD;;EAaA,OAAOP,gBAAP;AACH,CAvBqC,CAuBpCZ,UAvBoC,CAAtC","names":["tslib_1","Subscriber","filter","predicate","thisArg","filterOperatorFunction","source","FilterOperator","call","FilterSubscriber","_super","destination","_this","result","err","error"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/operators/filter.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n * Emit only click events whose target was a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { filter } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}