{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function timer(dueTime, periodOrScheduler, scheduler) {\n  if (dueTime === void 0) {\n    dueTime = 0;\n  }\n\n  var period = -1;\n\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = async;\n  }\n\n  return new Observable(function (subscriber) {\n    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();\n    return scheduler.schedule(dispatch, due, {\n      index: 0,\n      period: period,\n      subscriber: subscriber\n    });\n  });\n}\n\nfunction dispatch(state) {\n  var index = state.index,\n      period = state.period,\n      subscriber = state.subscriber;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}","map":{"version":3,"mappings":"AAAA;AACA,SAASA,UAAT,QAA2B,eAA3B;AACA,SAASC,KAAT,QAAsB,oBAAtB;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,OAAO,SAASC,KAAT,CAAeC,OAAf,EAAwBC,iBAAxB,EAA2CC,SAA3C,EAAsD;EACzD,IAAIF,OAAO,KAAK,KAAK,CAArB,EAAwB;IACpBA,OAAO,GAAG,CAAV;EACH;;EACD,IAAIG,MAAM,GAAG,CAAC,CAAd;;EACA,IAAIN,SAAS,CAACI,iBAAD,CAAb,EAAkC;IAC9BE,MAAM,GAAGC,MAAM,CAACH,iBAAD,CAAN,GAA4B,CAA5B,IAAiC,CAAjC,IAAsCG,MAAM,CAACH,iBAAD,CAArD;EACH,CAFD,MAGK,IAAIH,WAAW,CAACG,iBAAD,CAAf,EAAoC;IACrCC,SAAS,GAAGD,iBAAZ;EACH;;EACD,IAAI,CAACH,WAAW,CAACI,SAAD,CAAhB,EAA6B;IACzBA,SAAS,GAAGN,KAAZ;EACH;;EACD,OAAO,IAAID,UAAJ,CAAe,UAAUU,UAAV,EAAsB;IACxC,IAAIC,GAAG,GAAGT,SAAS,CAACG,OAAD,CAAT,GACJA,OADI,GAEH,CAACA,OAAD,GAAWE,SAAS,CAACK,GAAV,EAFlB;IAGA,OAAOL,SAAS,CAACM,QAAV,CAAmBC,QAAnB,EAA6BH,GAA7B,EAAkC;MACrCI,KAAK,EAAE,CAD8B;MAC3BP,MAAM,EAAEA,MADmB;MACXE,UAAU,EAAEA;IADD,CAAlC,CAAP;EAGH,CAPM,CAAP;AAQH;;AACD,SAASI,QAAT,CAAkBE,KAAlB,EAAyB;EACrB,IAAID,KAAK,GAAGC,KAAK,CAACD,KAAlB;EAAA,IAAyBP,MAAM,GAAGQ,KAAK,CAACR,MAAxC;EAAA,IAAgDE,UAAU,GAAGM,KAAK,CAACN,UAAnE;EACAA,UAAU,CAACO,IAAX,CAAgBF,KAAhB;;EACA,IAAIL,UAAU,CAACQ,MAAf,EAAuB;IACnB;EACH,CAFD,MAGK,IAAIV,MAAM,KAAK,CAAC,CAAhB,EAAmB;IACpB,OAAOE,UAAU,CAACS,QAAX,EAAP;EACH;;EACDH,KAAK,CAACD,KAAN,GAAcA,KAAK,GAAG,CAAtB;EACA,KAAKF,QAAL,CAAcG,KAAd,EAAqBR,MAArB;AACH","names":["Observable","async","isNumeric","isScheduler","scheduler","dueTime","period","Number","periodOrScheduler","subscriber","index","dispatch","state","closed"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/observable/timer.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport function timer(dueTime: number | Date = 0,\n                      periodOrScheduler?: number | SchedulerLike,\n                      scheduler?: SchedulerLike): Observable<number> {\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = async;\n  }\n\n  return new Observable(subscriber => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : (+dueTime - scheduler.now());\n\n    return scheduler.schedule(dispatch, due, {\n      index: 0, period, subscriber\n    });\n  });\n}\n\ninterface TimerState {\n  index: number;\n  period: number;\n  subscriber: Subscriber<number>;\n}\n\nfunction dispatch(this: SchedulerAction<TimerState>, state: TimerState) {\n  const { index, period, subscriber } = state;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}\n"]},"metadata":{},"sourceType":"module"}