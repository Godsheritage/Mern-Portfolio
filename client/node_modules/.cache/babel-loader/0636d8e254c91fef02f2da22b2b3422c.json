{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n  var resultSelector;\n  var initialState;\n\n  if (arguments.length == 1) {\n    var options = initialStateOrOptions;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions;\n    resultSelector = identity;\n    scheduler = resultSelectorOrObservable;\n  } else {\n    initialState = initialStateOrOptions;\n    resultSelector = resultSelectorOrObservable;\n  }\n\n  return new Observable(function (subscriber) {\n    var state = initialState;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        subscriber: subscriber,\n        iterate: iterate,\n        condition: condition,\n        resultSelector: resultSelector,\n        state: state\n      });\n    }\n\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n\n      var value = void 0;\n\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n\n      subscriber.next(value);\n\n      if (subscriber.closed) {\n        break;\n      }\n\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n\n    return undefined;\n  });\n}\n\nfunction dispatch(state) {\n  var subscriber = state.subscriber,\n      condition = state.condition;\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n\n  if (condition) {\n    var conditionResult = void 0;\n\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n\n  var value;\n\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  subscriber.next(value);\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  return this.schedule(state);\n}","map":{"version":3,"mappings":"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","names":["Observable","identity","isScheduler","generate","initialStateOrOptions","condition","iterate","resultSelectorOrObservable","scheduler","resultSelector","initialState","arguments","options","undefined","subscriber","state","dispatch","conditionResult","err","value"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/observable/generate.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { identity } from '../util/identity';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\n\nexport type ConditionFunc<S> = (state: S) => boolean;\nexport type IterateFunc<S> = (state: S) => S;\nexport type ResultFunc<S, T> = (state: S) => T;\n\ninterface SchedulerState<T, S> {\n  needIterate?: boolean;\n  state: S;\n  subscriber: Subscriber<T>;\n  condition?: ConditionFunc<S>;\n  iterate: IterateFunc<S>;\n  resultSelector: ResultFunc<S, T>;\n}\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\n *\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n * const res = generate(1, x => x < 5, x => x * 2, x => x + 1, asap);\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n */\n  export function generate<T, S>(initialState: S,\n                                 condition: ConditionFunc<S>,\n                                 iterate: IterateFunc<S>,\n                                 resultSelector: ResultFunc<S, T>,\n                                 scheduler?: SchedulerLike): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * <img src=\"./img/generate.png\" width=\"100%\">\n *\n * `generate` allows you to create stream of values generated with a loop very similar to\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * loop continues, if not, it stops. Third value is a function which takes previously defined\n * value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in regular for loop: first expression\n * initializes some state (for example numeric index), second tests if loop can make next\n * iteration (for example if index is lower than 10) and third states how defined value\n * will be modified on every step (index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First, condition function is ran. If it returned true, Observable\n * emits currently stored value (initial value at the first iteration) and then updates\n * that value with iterate function. If at some point condition returned false, Observable\n * completes at that moment.\n *\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\n * to immediately map value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * single object to the operator instead. That object has properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, so output Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is resultSelector\n * function or not). In case of single-parameter call, you can provide it as a\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\n * next iteration of the loop will happen and therefore when next value will be emitted\n * by the Observable. For example to ensure that each value is pushed to the observer\n * on separate task in event loop, you could use `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * @example <caption>Use with condition and iterate functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with options object.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n * @example <caption>Use options object without condition function.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!') // This will never run.\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n *\n *\n * @see {@link from}\n * @see {@link index/Observable.create}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n */\nexport function generate<S>(initialState: S,\n                            condition: ConditionFunc<S>,\n                            iterate: IterateFunc<S>,\n                            scheduler?: SchedulerLike): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n *   resultSelector: x => x,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>,\n                               condition?: ConditionFunc<S>,\n                               iterate?: IterateFunc<S>,\n                               resultSelectorOrObservable?: (ResultFunc<S, T>) | SchedulerLike,\n                               scheduler?: SchedulerLike): Observable<T> {\n\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  if (arguments.length == 1) {\n    const options = initialStateOrOptions as GenerateOptions<T, S>;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity as ResultFunc<S, T>;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions as S;\n    resultSelector = identity as ResultFunc<S, T>;\n    scheduler = resultSelectorOrObservable as SchedulerLike;\n  } else {\n    initialState = initialStateOrOptions as S;\n    resultSelector = resultSelectorOrObservable as ResultFunc<S, T>;\n  }\n\n  return new Observable<T>(subscriber => {\n    let state = initialState;\n    if (scheduler) {\n      return scheduler.schedule<SchedulerState<T, S>>(dispatch, 0, {\n        subscriber,\n        iterate,\n        condition,\n        resultSelector,\n        state\n      });\n    }\n\n    do {\n      if (condition) {\n        let conditionResult: boolean;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      let value: T;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n\n    return undefined;\n  });\n}\n\nfunction dispatch<T, S>(this: SchedulerAction<SchedulerState<T, S>>, state: SchedulerState<T, S>) {\n  const { subscriber, condition } = state;\n  if (subscriber.closed) {\n    return undefined;\n  }\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n  if (condition) {\n    let conditionResult: boolean;\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n  let value: T;\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n  if (subscriber.closed) {\n    return undefined;\n  }\n  subscriber.next(value);\n  if (subscriber.closed) {\n    return undefined;\n  }\n  return this.schedule(state);\n}\n"]},"metadata":{},"sourceType":"module"}