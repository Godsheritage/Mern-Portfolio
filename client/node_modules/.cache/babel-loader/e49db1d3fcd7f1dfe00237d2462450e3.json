{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_.._internal_symbol_iterator,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function zip() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i] = arguments[_i];\n  }\n\n  var resultSelector = observables[observables.length - 1];\n\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\n\nvar ZipOperator = /*@__PURE__*/function () {\n  function ZipOperator(resultSelector) {\n    this.resultSelector = resultSelector;\n  }\n\n  ZipOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  };\n\n  return ZipOperator;\n}();\n\nexport { ZipOperator };\n\nvar ZipSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ZipSubscriber, _super);\n\n  function ZipSubscriber(destination, resultSelector, values) {\n    if (values === void 0) {\n      values = Object.create(null);\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.resultSelector = resultSelector;\n    _this.iterators = [];\n    _this.active = 0;\n    _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : undefined;\n    return _this;\n  }\n\n  ZipSubscriber.prototype._next = function (value) {\n    var iterators = this.iterators;\n\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  };\n\n  ZipSubscriber.prototype._complete = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n    this.unsubscribe();\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (iterator.stillUnsubscribed) {\n        var destination = this.destination;\n        destination.add(iterator.subscribe());\n      } else {\n        this.active--;\n      }\n    }\n  };\n\n  ZipSubscriber.prototype.notifyInactive = function () {\n    this.active--;\n\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype.checkIterators = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n    var destination = this.destination;\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    var shouldComplete = false;\n    var args = [];\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n      var result = iterator.next();\n\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype._tryresultSelector = function (args) {\n    var result;\n\n    try {\n      result = this.resultSelector.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return ZipSubscriber;\n}(Subscriber);\n\nexport { ZipSubscriber };\n\nvar StaticIterator = /*@__PURE__*/function () {\n  function StaticIterator(iterator) {\n    this.iterator = iterator;\n    this.nextResult = iterator.next();\n  }\n\n  StaticIterator.prototype.hasValue = function () {\n    return true;\n  };\n\n  StaticIterator.prototype.next = function () {\n    var result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  };\n\n  StaticIterator.prototype.hasCompleted = function () {\n    var nextResult = this.nextResult;\n    return Boolean(nextResult && nextResult.done);\n  };\n\n  return StaticIterator;\n}();\n\nvar StaticArrayIterator = /*@__PURE__*/function () {\n  function StaticArrayIterator(array) {\n    this.array = array;\n    this.index = 0;\n    this.length = 0;\n    this.length = array.length;\n  }\n\n  StaticArrayIterator.prototype[Symbol_iterator] = function () {\n    return this;\n  };\n\n  StaticArrayIterator.prototype.next = function (value) {\n    var i = this.index++;\n    var array = this.array;\n    return i < this.length ? {\n      value: array[i],\n      done: false\n    } : {\n      value: null,\n      done: true\n    };\n  };\n\n  StaticArrayIterator.prototype.hasValue = function () {\n    return this.array.length > this.index;\n  };\n\n  StaticArrayIterator.prototype.hasCompleted = function () {\n    return this.array.length === this.index;\n  };\n\n  return StaticArrayIterator;\n}();\n\nvar ZipBufferIterator = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ZipBufferIterator, _super);\n\n  function ZipBufferIterator(destination, parent, observable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.parent = parent;\n    _this.observable = observable;\n    _this.stillUnsubscribed = true;\n    _this.buffer = [];\n    _this.isComplete = false;\n    return _this;\n  }\n\n  ZipBufferIterator.prototype[Symbol_iterator] = function () {\n    return this;\n  };\n\n  ZipBufferIterator.prototype.next = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length === 0 && this.isComplete) {\n      return {\n        value: null,\n        done: true\n      };\n    } else {\n      return {\n        value: buffer.shift(),\n        done: false\n      };\n    }\n  };\n\n  ZipBufferIterator.prototype.hasValue = function () {\n    return this.buffer.length > 0;\n  };\n\n  ZipBufferIterator.prototype.hasCompleted = function () {\n    return this.buffer.length === 0 && this.isComplete;\n  };\n\n  ZipBufferIterator.prototype.notifyComplete = function () {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  ZipBufferIterator.prototype.notifyNext = function (innerValue) {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  };\n\n  ZipBufferIterator.prototype.subscribe = function () {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  };\n\n  return ZipBufferIterator;\n}(SimpleOuterSubscriber);","map":{"version":3,"mappings":"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","names":["tslib_1","fromArray","isArray","Subscriber","iterator","SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","_i","resultSelector","observables","ZipOperator","call","subscriber","source","ZipSubscriber","_super","values","create","destination","_this","undefined","_next","iterators","push","StaticArrayIterator","value","StaticIterator","_complete","len","length","unsubscribe","complete","active","i","notifyInactive","checkIterators","shouldComplete","args","result","next","prototype","_tryresultSelector","apply","err","error","hasCompleted","array","done","index","ZipBufferIterator","parent","observable","buffer","notifyComplete","isComplete","notifyNext","subscribe"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/observable/zip.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { ObservableInput, PartialObserver, ObservedValueOf } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): Observable<R>;\n\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n\nexport function zip<O extends ObservableInput<any>>(array: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: any[]) => R): Observable<R>;\n\nexport function zip<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n * Combine age and name from different sources\n * ```ts\n * import { zip, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * let age$ = of<number>(27, 25, 29);\n * let name$ = of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = of<boolean>(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev })),\n * )\n * .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zip<O extends ObservableInput<any>, R>(\n  ...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>\n): Observable<ObservedValueOf<O>[]|R> {\n  const resultSelector = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  resultSelector?: (...values: Array<any>) => R;\n\n  constructor(resultSelector?: (...values: Array<any>) => R) {\n    this.resultSelector = resultSelector;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              private resultSelector?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    this.unsubscribe();\n\n    if (len === 0) {\n      this.destination.complete!();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        const destination = this.destination as Subscription;\n        destination.add(iterator.subscribe());\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete!();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete!();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next!(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete!();\n    }\n  }\n\n  protected _tryresultSelector(args: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector!.apply(this, args);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted(): boolean {\n    const nextResult = this.nextResult;\n    return Boolean(nextResult && nextResult.done);\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends SimpleOuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift()!, done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete!();\n    }\n  }\n\n  notifyNext(innerValue: any): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe() {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}