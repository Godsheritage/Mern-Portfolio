{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\n\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n\nexport { AsyncScheduler };","map":{"version":3,"mappings":"AAAA;AACA,OAAO,KAAKA,OAAZ,MAAyB,OAAzB;AACA,SAASC,SAAT,QAA0B,cAA1B;;AACA,IAAIC,cAAc,GAAG,aAAe,UAAUC,MAAV,EAAkB;EAClDH,OAAO,CAACI,SAAR,CAAkBF,cAAlB,EAAkCC,MAAlC;;EACA,SAASD,cAAT,CAAwBG,eAAxB,EAAyCC,GAAzC,EAA8C;IAC1C,IAAIA,GAAG,KAAK,KAAK,CAAjB,EAAoB;MAChBA,GAAG,GAAGL,SAAS,CAACK,GAAhB;IACH;;IACD,IAAIC,KAAK,GAAGJ,MAAM,CAACK,IAAP,CAAY,IAAZ,EAAkBH,eAAlB,EAAmC,YAAY;MACvD,IAAIH,cAAc,CAACO,QAAf,IAA2BP,cAAc,CAACO,QAAf,KAA4BF,KAA3D,EAAkE;QAC9D,OAAOL,cAAc,CAACO,QAAf,CAAwBH,GAAxB,EAAP;MACH,CAFD,MAGK;QACD,OAAOA,GAAG,EAAV;MACH;IACJ,CAPW,KAON,IAPN;;IAQAC,KAAK,CAACG,OAAN,GAAgB,EAAhB;IACAH,KAAK,CAACI,MAAN,GAAe,KAAf;IACAJ,KAAK,CAACK,SAAN,GAAkBC,SAAlB;IACA,OAAON,KAAP;EACH;;EACDL,cAAc,CAACY,SAAf,CAAyBC,QAAzB,GAAoC,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,KAAvB,EAA8B;IAC9D,IAAID,KAAK,KAAK,KAAK,CAAnB,EAAsB;MAClBA,KAAK,GAAG,CAAR;IACH;;IACD,IAAIf,cAAc,CAACO,QAAf,IAA2BP,cAAc,CAACO,QAAf,KAA4B,IAA3D,EAAiE;MAC7D,OAAOP,cAAc,CAACO,QAAf,CAAwBM,QAAxB,CAAiCC,IAAjC,EAAuCC,KAAvC,EAA8CC,KAA9C,CAAP;IACH,CAFD,MAGK;MACD,OAAOf,MAAM,CAACW,SAAP,CAAiBC,QAAjB,CAA0BP,IAA1B,CAA+B,IAA/B,EAAqCQ,IAArC,EAA2CC,KAA3C,EAAkDC,KAAlD,CAAP;IACH;EACJ,CAVD;;EAWAhB,cAAc,CAACY,SAAf,CAAyBK,KAAzB,GAAiC,UAAUC,MAAV,EAAkB;IAC/C,IAAIV,OAAO,GAAG,KAAKA,OAAnB;;IACA,IAAI,KAAKC,MAAT,EAAiB;MACbD,OAAO,CAACW,IAAR,CAAaD,MAAb;MACA;IACH;;IACD,IAAIE,KAAJ;IACA,KAAKX,MAAL,GAAc,IAAd;;IACA,GAAG;MACC,IAAIW,KAAK,GAAGF,MAAM,CAACG,OAAP,CAAeH,MAAM,CAACF,KAAtB,EAA6BE,MAAM,CAACH,KAApC,CAAZ,EAAwD;QACpD;MACH;IACJ,CAJD,QAISG,MAAM,GAAGV,OAAO,CAACc,KAAR,EAJlB;;IAKA,KAAKb,MAAL,GAAc,KAAd;;IACA,IAAIW,KAAJ,EAAW;MACP,OAAOF,MAAM,GAAGV,OAAO,CAACc,KAAR,EAAhB,EAAiC;QAC7BJ,MAAM,CAACK,WAAP;MACH;;MACD,MAAMH,KAAN;IACH;EACJ,CApBD;;EAqBA,OAAOpB,cAAP;AACH,CApDmC,CAoDlCD,SApDkC,CAApC;;AAqDA,SAASC,cAAT","names":["tslib_1","AsyncScheduler","_super","now","Scheduler","_this","prototype","work","delay","state","schedule","call","actions","active","action","error"],"sources":["/Users/godsheritageadeoye/Documents/GitHub/Mern-Portfolio/client/node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts"],"sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}